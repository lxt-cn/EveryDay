#pragma once

#include <iostream>
#include <vector>
#include <string>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
两个编程题：
	1>、星际密码
	2>、数根 
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

1. 标题：星际密码 | 时间限制：1秒 | 内存限制：32768K 
	星际战争开展了100年之后，NowCoder终于破译了外星人的密码！他们的密码是一串整数，通过一张表里的信息映射成最终4位密码。
	表的规则是：n对应的值是矩阵X的n次方的左上角，如果这个数不足4位则用0填充，如果大于4位的则只输出最后4位。
	|1 1|^n => |Xn ..|
	|1 0|      |.. ..|
	例如n=2时，
	|1 1|^2 => |1 1| * |1 1| => |2 1|
	|1 0|      |1 0|   |1 0|    |1 1|
	即2对应的数是“0002”。

	输入描述： 
		输入有多组数据。
		每组数据两行：第一行包含一个整数n (1≤n≤100)；第二行包含n个正整数Xi (1≤Xi≤10000)
	输出描述： 
		对应每一组输入，输出一行相应的密码。 
		
	示例1: 
		输入 
			6 
			18 15 21 13 25 27 
			5 
			1 10 100 1000 10000 
		输出 
			418109877711037713937811 
			00010089410135017501

*/
/*
【题目解析】：
	这个题目首先需要明确矩阵是固定的，其次是矩阵相乘的方法。
	矩阵相乘   
		|a1 a2| * |c1 c2| = |a1c1 + a2d1 a1c2 + a2d2|   
		|b1 b2|   |d1 d2|   |b1c1 + b2d1 b1d2 + b2d2|
	矩阵是
		|1 1|^2 = |1 1|*|1 1|=|2 1| 
		|1 0|	  |1 0| |1 0| |1 1| 
	n的取值：1 2 3 4 5 6 .... 
	左上角值：1 2 3 5 8 13 .... 是一 个变式的斐波那契

【解题思路】：
	初始化斐波那契数列，每次获取对应数据，打印最后4位即可
*/

std::vector<int> a = { 1,1 }; 
void data_init() 
{
	int i;
	for (i = 2; i < 10005; i++)
	{
		a.push_back((a[i - 1] + a[i - 2]) % 10000);
	}
}

void ED01() 
{
	int n, t; 
	data_init();
	while (cin >> n)
	{
		while (n--) 
		{
			cin >> t; 
			printf("%04d", a[t]);
		}      
		cout << endl;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

2. 标题：数根 | 时间限制：1秒 | 内存限制：32768K 
	数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；如果 结果是两位数或者包括更多位的数字，
那么再把这些数字加起来。如此进行下去，直到得到是一位数为止。
	比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。
	再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一 位数，因此3 是39 的数根。
	现在给你一个正整数，输出它的数根。

	输入描述： 
		输入包含多组数据。
		每组数据数据包含一个正整数n（1≤n≤10E1000）。
	输出描述： 
		对应每一组数据，输出该正整数的数根。 
	
	示例1:
		输入 
			24 39 
		输出 
			6 3

*/
/*
【题目解析】：这个题目很容易理解，对于数字的每一位进行相加直到不大于9为止即可
【解题思路】：
	1. 接收字符串得到各个数字，并且每位求和（为了得到的数字不大于99）
    2. 循环对大于9的数字进行对10取余和整除操作，将两个结果进行相加得到树根
*/

int numRoot(int num)
{ 
	int nroot = 0;  
	while (num > 0)
	{       
		/*每次只获取个位数字---个位数+十位数*/   
		nroot += num % 10;   
		num /= 10;
	}     
	while (nroot > 9)
	{ 
		nroot = numRoot(nroot); 
	}      
	return nroot;
} 

void ED02() {
	std::string origin; 
	while (cin >> origin)
	{
		int sum = 0;   
		//先将每一位进行相加得到总和，防止数字过大    
		for (int i = 0; i < origin.length(); i++)
		{         
			sum += origin[i] - '0';    
		}        
		//对总和求树根   
		cout << numRoot(sum) << std::endl;  
	}  
} 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	//ED01();
	ED02();
	return 0;
}
