#include <iostream>
#include <vector>
#include <string>
using namespace std;

///////////////////////////////////////////////////////////////////////////////////////////
/*
两个编程题：
	1>、杨辉三角的变形
	2>、超长正整数相加
*/
///////////////////////////////////////////////////////////////////////////////////////////

/*
1>
标题：iNOC产品部-杨辉三角的变形 | 时间限制：1秒 | 内存限制：32768K
						1
					1   1   1
				1   2   3   2   1
			1   3   6   7   6   3   1
		1   4  10  16  19  16  10   4   1
	以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数，左上角数到右上角的
数，3个数之和（如果不存在某个数，认为该数就是0）。
	求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3。
	输入n(n <= 1000000000)

	输入描述：
		输入一个int整数
	输出描述：
		输出返回的int值
*/

void ED01()
{
	int n = 0;
	int m = 0;
	while (cin >> n)
	{
		m = 2 * n - 1;
		vector<vector<int>> dp(n, vector<int>(m, 0));
		dp[0][0] = 1;	// 设置第一行
		for (int i = 1; i < n; i++)
		{
			//第一列和最后一列都为1
			dp[i][0] = dp[i][2 * i] = 1;
			for (int j = 1; j < 2 * i; ++j)
			{
				if (i == 1 && j == 1)
				{
					dp[i][j] = 1;
				}
				else if (j == 1)
					//如果是第二列，则只是两个元素之和
					dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
				else
					//第i,j元素等于上一行第j - 2,j - 1,j三列元素之和
					dp[i][j] = dp[i - 1][j - 2] + dp[i - 1][j - 1] + dp[i - 1][j];
			}
		}
		int k = 0;
		for (k = 0; k < m; k++)
		{
			if (dp[n - 1][k] % 2 == 0 && dp[n - 1][k] != 0)
			{
				cout << k + 1 << endl;
				break;
			}
		}
		if (k == m)
			cout << -1 << endl;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////

/*
2>
标题：超长正整数相加 | 时间限制：1秒 | 内存限制：32768K
	请设计一个算法完成两个超长正整数的加法。

	接口说明

	输入参数：
		String addend：加数
		String augend：被加数
	返回值：加法结果

	public String AddLongInteger(String addend, String augend)
	{
		//在这里实现功能
		return null;
	}

	输入描述：
		输入两个字符串数字
	输出描述：
		输出相加后的结果，string型

	示例1:
		输入
			99999999999999999999999999999999999999999999999999
			1
		输出
			100000000000000000000000000000000000000000000000000

*/
string addStrings(string num1, string num2)
{
	//由低位向高位相加
	int i = num1.size() - 1;
	int j = num2.size() - 1;
	string result = "";
	//当前位的相加结果
	int carry = 0;
	while (i >= 0 || j >= 0)
	{
		if (i >= 0) {
			carry += num1[i] - '0';
		}
		if (j >= 0) {
			carry += num2[j] - '0';
		}
		//当前为的最大值不大于10
		result += (char)(carry % 10 + '0');
		//如果大于10,向上进一位
		carry /= 10;
		i--;
		j--;
	}
	//相加完之后，如果还有进位，则再加1
	if (carry == 1)
	{
		result += '1';
	}
	//整体逆置
	reverse(result.begin(), result.end());
	return result;
}

void ED02()
{
	string s1, s2;
	while (cin >> s1 >> s2)
	{
		cout << addStrings(s1, s2) << endl;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
int main()
{
	//ED01();
	ED02();
	return 0;
}