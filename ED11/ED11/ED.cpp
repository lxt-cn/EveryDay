#include <iostream>
using namespace std;

//////////////////////////////////////////////////////////////////////////////////////
/*

两个编程题：
	1>、最近公共祖先
	2>、求最大连续bit数

*/
//////////////////////////////////////////////////////////////////////////////////////

/*

1>
标题：最近公共祖先 | 时间限制：3秒 | 内存限制：32768K | 语言限制：[Python, C++, C#, Java]
	有一棵无穷大的满二叉树，其结点按根结点一层一层地从左往右依次编号，根结点编号为1。
现在有两个结点a，b。请设计一个算法，求出a和b点的最近公共祖先的编号。给定两个int a,b。
为给定结点的编号。请返回a和b的最近公共祖先的编号。注意这里结点本身也可认为是其祖先。

*/

/*

思路：
	题目所描述的满二叉树如下： 
				1 
			   / \ 
			  2   3 
			 / \ / \ 
			4  5 6  7 
	.....
	上述树中子节点与父节点之间的关系为root = child / 2 ，所以如果a ！= b，就让其中的较大数除以2， 
如此循环直到a == b 即是原来两个数的最近公共祖先 
    比如： 2和7的最近公共祖先：7/2 = 3 ---> 3/2 = 1， 2/2 = 1， 得到1为它们的公共祖先

*/

class LCA {
public:
	int getLCA(int a, int b) {
		while (a != b)
		{
			if (a > b)
				a /= 2;
			else
				b /= 2;
		}
		return a;
	}
};
void ED01()
{
	LCA lca;
	while (1)
	{
		int a = 0;
		int b = 0;
		cin >> a >> b;
		cout << lca.getLCA(a, b) << endl;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////

/*

2>
标题：求最大连续bit数 | 时间限制：1秒 | 内存限制：32768K
	功能: 求一个byte数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1
	
	输入: 
		一个byte型的数字
	输出: 
		无

	返回: 对应的二进制数字中1的最大连续数

	输入描述：
		输入一个byte数字
	输出描述：
		输出转成二进制之后连续1的个数

*/
int MaxLine(int by)
{
	int max = 0;
	int count = 0;
	while (by)
	{
		if ((by & 1) == 1)
		{
			count++;
		}
		else
		{
			count = 0;
		}
		if (max < count)
		{
			max = count;
		}
		by = by >> 1;
	}
	return max;
}

void ED02()
{
	int by = 0;
	while (cin >> by)
	{
		cout << MaxLine(by) << endl;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	ED01();
	ED02();
	return 0;
}
