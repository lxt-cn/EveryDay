#pragma once

#include <iostream>
#include <string>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
两个编程题：
	1>、剪花布条 
	2>、客似云来
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

1. 标题：剪花布条 | 时间限制：1秒 | 内存限制：32768K 
	一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰 条，计算一下能从花布条
中尽可能剪出几块小饰条来呢？

	输入描述： 
		输入包含多组数据。
		每组数据包含两个字符串s,t，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，
		布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。 
	输出描述： 
		对应每组输入，输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就输出0，每个结果占一行。 
		
	示例1: 
		输入 
			abcde a3 
			aaaaaa aa 
		输出 
			0 
			3

*/

void ED01() {
	std::string s, t; 
	while (std::cin >> s >> t) 
	{
		int res = 0; 
		size_t pos = 0;   
		//依次在 s 中查找 t 即可，直到再也找不到 t  
		while ((pos = s.find(t, pos)) != std::string::npos)
		{
			pos += t.size(); //跳过t串整体的长度      
			++res; //计数    
		}

		std::cout << res << std::endl;
	} 
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

2. 标题：客似云来 | 时间限制：1秒 | 内存限制：32768K 
	NowCoder开了一家早餐店，这家店的客人都有个奇怪的癖好：他们只要来这家店吃过一次早餐，就会每天都过来；并且，所有人在这家店
吃了两天早餐后，接下来每天都会带一位新朋友一起来品尝。于是，这家店的客人从最初一个人发展成浩浩荡荡成百上千人：1、1、2、3、5
…… 现在，NowCoder想请你帮忙统计一下，某一段时间范围那他总共卖出多少份早餐（假设每位客人只吃一份 早餐）。

	输入描述： 
		测试数据包括多组。 
		每组数据包含两个整数from和to(1≤from≤to≤80)，分别代表开店的第from天和第to天。 
	输出描述： 
		对应每一组输入，输出从from到to这些天里（包含from和to两天），需要做多少份早餐。 
	
	示例1:
		输入 
			1 10
			2 8
			36 80
		输出
			143
			53
			61305790697453774

*/

#define MAX 83 //如果用公式计算，需要接下来两项的值

void solve(long long num[]) 
{
	for (int i = 2; i < MAX; i++)
	{
		num[i] = num[i - 1] + num[i - 2]; 
	}
}

//解法1：用遍历求和求解
long long sum_traversal(long long num[], int from, int to) 
{
	long long ans = 0;  
	//让数组下标从from - 1遍历到to - 1
	for (int i = from - 1; i < to; i++)
	{
		ans += num[i];   
	}
	return ans; 
}

//解法2：用公式求解
long long sum_formula(long long num[], int from, int to)
{
	return num[to + 1] - num[from];  //第to + 2项的下标是to + 1，第from + 2 - 1项的下标是from
}

void ED02() {
	int from, to;
	long long num[MAX] = { 1, 1 };
	//提前计算Fibonacci数列    
	solve(num); 
	while (std::cin >> from >> to) 
	{
		std::cout << sum_formula(num, from, to) << std::endl; //两个方法二选一。公式更快。
		//std::cout << sum_traversal(num, from, to) << std::endl; 
	} 
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	//ED01();
	ED02();
	return 0;
}
