#pragma once

#include <iostream>
#include <vector>
#include <math.h>
using namespace std;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
两个编程题：
	1>、奇数位上都是奇数或者偶数位上都是偶数
	2>、猴子分桃
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*

1. 标题：奇数位上都是奇数或者偶数位上都是偶数 | 时间限制：1秒 | 内存限制：32768K | 
	写一个函数调整 arr ，使 arr 中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 
	要求：
		如果数组长度为 N ，时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1),下标 0,2,4,6...算作偶数位,下标 1,3,5,7...算作奇数位，
	
	例如 [1,2,3,4] 调整为 [2,1,4,3] 即可

*/

// 在偶数位上寻找非偶数，在奇数位上寻找非奇数，两个数字进行位置互换即可
class Solution {
public:  
	void oddInOddEvenInEven(vector<int>& arr, int len)
	{
		long i = 0, j = 1;   
		while (i < len && j < len) 
		{
			//偶数位上寻找非偶数
			if ((arr[i] % 2) == 0)
			{ 
				i += 2; 
				continue; 
			}     
			//奇数位上寻找非奇数 
			if((arr[j] % 2) != 0) 
			{
				j += 2;
				continue;
			}          
			swap(arr[i], arr[j]);  
		}   
	}
};

void ED01()
{
	Solution s;
	vector<int> arr;
	int arr1[4] = { 1,2,3,4 };
	for (int i = 0; i < 4; ++i)
	{
		arr.push_back(arr1[i]);
	}
	s.oddInOddEvenInEven(arr, 4);
	for (int i = 0; i < 4; ++i)
	{
		cout << arr[i] << endl;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*

2. 标题：猴子分桃 | 时间限制：1秒 | 内存限制：32768K 
	老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富 ―― 一大堆桃子。老猴子决定把这些桃子分给小猴子。
第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。

	输入描述： 
		输入包括多组测试数据。 
		每组测试数据包括一个整数n(1≤n≤20)。 输入以0结束，该行不做处理。 
	输出描述：
		每组测试数据对应一行输出。 
		包括两个整数a，b。 分别代表开始时最小需要的桃子数，和结束后老猴子最少能得到的桃子数。
		
	示例1:
		输入
			5
			1
			0 
		输出 
			3121 1025 
			1 1

*/

/*
【解题思路】：公式类推
 
	因为每次分 5 堆都会多出来 1 个，所以我们借给猴子们 4 个，以致每次都可以刚好分成 5 堆   
并且，每次给老猴子的桃子都不在我们借出的那4个中，这样最后减掉4就可以得到结果。   
	假设最初由 x 个桃子，我们借给猴子 4 个，则此时有 x+4 个,第一个猴子得到（x+4）/5，剩余（x+4）（4/5）个  
第二个猴子分完后剩余（x+4） (4/5)^2个   第三个 猴子分完后剩余（x+4） (4/5)^3个   依次类推，第n个猴子分完后剩余（x+4）（4/5）^n   要满足最后剩余的为整 数，并且x最小，则当 x+4=5^n时，满足要求；此时，x=5^n - 4;   老猴子得到的数量为：x+4）*（4/5）^n + n - 4 = 4^n + n - 4   最后的 +n是因为每个小猴子都会多出一个给老猴子，-4是还了借的4个

*/

void ED02()
{
	int n;
	while (cin >> n)
	{
		if (n == 0)
			break;
		long total = pow(5, n) - 4;
		long left = pow(4, n) + n - 4;
		cout << total << " " << left << endl;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	//ED01();
	ED02();
	return 0;
}